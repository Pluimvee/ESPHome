# Copyright (c) 2026 Pluimvee
# Peak shaving controller for Solis inverter

substitutions:
  device_id: "peak-shaver"
  build_root: !secret build_root

esphome:
  name: ${device_id}
  build_path: ${build_root}/${device_id}
  friendly_name: Solis Peak Shaver

esp32:
  board: esp32dev
  framework:
    type: esp-idf

logger:
  level: INFO
  baud_rate: 0
  logs:
    uart: WARN
    sensor: WARN
    number: WARN
    p1_dsmr: WARN
    modbus_controller.sensor: WARN
    modbus_controller.number: WARN

api:
  encryption:
    key: !secret api_key

ota:
  - platform: esphome
    password: !secret ota_password

mdns:
  disabled: false

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  fast_connect: true
  power_save_mode: none
  ap:
    ssid: "Peak Shaver Hotspot"
    password: !secret wifi_ap_password

captive_portal:

web_server:
    port: 80
    version: 3

external_components:
  - source: github://Pluimvee/esphome-dsmr
    refresh: 1min

uart:
  # P1 DSMR (pas aan aan jouw meter)
  - id: uart_p1
    rx_pin:
      number: GPIO18
      inverted: true
    baud_rate: 115200     # DSMR v5.x = 115200 8N1; v2/4 vaak 9600 7E1
    data_bits: 8
    parity: NONE
    stop_bits: 1
    rx_buffer_size: 4096
    
  # RS485 Modbus (Solis inverter)
  - id: uart_rs485
    rx_pin: GPIO16
    tx_pin: GPIO17
    baud_rate: 9600
    data_bits: 8
    parity: NONE
    stop_bits: 1
    rx_buffer_size: 512

p1_dsmr:
  uart_id: uart_p1
  update_interval: 5s
  obis_validity: 10s
  sensors:
    - id: power_import
      obis: "1-0:1.7.0"
      name: "Power Import"
      unit_of_measurement: "W"
      device_class: power
      state_class: measurement
      accuracy_decimals: 0
      internal: true
      on_value:
        then:
          - component.update: grid_power
    - id: power_export
      obis: "1-0:2.7.0"
      name: "Power Export"
      unit_of_measurement: "W"
      device_class: power
      state_class: measurement
      accuracy_decimals: 0
      internal: true
      on_value:
        then:
          - component.update: grid_power

modbus:
  - id: modbus1
    uart_id: uart_rs485

modbus_controller:
  - id: solis
    address: 1
    modbus_id: modbus1
    update_interval: 5s
    setup_priority: -10

sensor:
  - platform: wifi_signal
    name: "WiFi Signal Strength"
    icon: "mdi:wifi"
    update_interval: 60s

  - id: grid_power
    platform: template
    name: "Grid Power"
    icon: "mdi:flash"
    unit_of_measurement: "W"
    device_class: power
    state_class: measurement
    accuracy_decimals: 0
    lambda: |-
      if (isnan(id(power_import).state) || isnan(id(power_export).state)) return NAN;
      return id(power_import).state - id(power_export).state;

  - id: battery_power
    platform: modbus_controller
    modbus_controller_id: solis
    name: "Battery Power"
    icon: "mdi:battery-charging"
    register_type: read
    address: 33151
    value_type: S_DWORD
    unit_of_measurement: "W"
    device_class: power
    state_class: measurement
    accuracy_decimals: 0

  - id: home_power
    platform: template
    name: "Home Power"
    icon: "mdi:home-lightning-bolt-outline"
    unit_of_measurement: "W"
    device_class: power
    state_class: measurement
    accuracy_decimals: 0
    lambda: |-
      if (isnan(id(grid_power).state) || isnan(id(battery_power).state)) return NAN;
      return id(grid_power).state + id(battery_power).state;
    update_interval: 5s

  - id: home_power_avg
    platform: template
    name: "Home Power Average"
    unit_of_measurement: "W"
    device_class: power
    icon: "mdi:home-analytics"
    state_class: measurement
    accuracy_decimals: 0
    lambda: |-
      return id(home_power).state;
    update_interval: 5s
    filters:
      - sliding_window_moving_average:
          window_size: 12
          send_every: 1

  - platform: modbus_controller
    modbus_controller_id: solis
    id: battery_soc
    name: "Battery SOC"
    icon: "mdi:battery-medium"
    register_type: read
    address: 33139
    value_type: U_WORD
    unit_of_measurement: "%"
    device_class: battery
    state_class: measurement
    accuracy_decimals: 0

  - id: estimated_battery_drain
    platform: template
    name: "Estimated Battery Drain"
    unit_of_measurement: "h"
    icon: "mdi:battery-clock-outline"
    accuracy_decimals: 1
    lambda: |-
      if (isnan(id(battery_soc).state) || isnan(id(battery_power).state)) return NAN;
      const float P_w = id(battery_power).state;   // >0 = discharge
      if (P_w <= 50.0f) return NAN;                // dode zone / ruis
      float soc_eff = id(battery_soc).state - 7.0f;  // reserve 7% SOC
      if (soc_eff <= 0.0f) return 0.0f;
      const float remaining_wh = soc_eff * 0.01f * 20000.0f;  // 20 kWh battery
      return remaining_wh / P_w;
    update_interval: 10s

number:
  - platform: template
    id: grid_power_target
    name: "Grid Power Target"
    icon: "mdi:tune-vertical"
    initial_value: 0
    unit_of_measurement: "W"
    device_class: power
    min_value: -12000
    max_value: 12000
    step: 500
    optimistic: true
    restore_value: true

  - platform: modbus_controller
    modbus_controller_id: solis
    id: battery_power_target
    name: "Battery Power Target"
    icon: "mdi:cog-transfer-outline"
    register_type: holding
    address: 43128
    value_type: S_WORD
    multiply: 0.1
    min_value: -10000
    max_value: 10000
    step: 1

  - platform: modbus_controller
    modbus_controller_id: solis
    id: rc_grid_adjust_mode
    name: "RC Grid Adjustment Mode Set"
    register_type: holding
    address: 43132
    value_type: U_WORD
    min_value: 0
    max_value: 2
    step: 1
    internal: true

switch:
  - platform: template
    id: enable
    name: "Enable"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF

interval:
  # Interval of 10s as DSMR doenst update more frequently
  - interval: 5s
    then:
      - lambda: |-
          auto set_num = [](esphome::number::Number *num, float value) {
            auto call = num->make_call();
            call.set_value(value);
            call.perform();
          };
          const float max_power_w = 10000.0f;
          const float max_step_w = 500.0f;

          if (!id(enable).state) {
            set_num(id(rc_grid_adjust_mode), 0.0f);
            return;
          }
          set_num(id(rc_grid_adjust_mode), 2.0f);

          if (!id(battery_power_target).has_state())
            return;
          const float grid = id(grid_power).state;
          const float home = id(home_power_avg).state;
          const float target = id(grid_power_target).state;

          // set battery power to average house_hold power minus target
          float u_new = home - target;   

          // PI correction
          float err = target - grid;
          // u_new -= err * 0.50f;   // P-gain

          if (fabs(u_new) < 100.0f) {
            u_new = 0.0f;
          } 
          if (!isnan(id(battery_soc).state) && id(battery_soc).state < 7.0f && u_new > 0.0f) {
            u_new = 0.0f;
            ESP_LOGW("peak_shaver", "Battery SOC low (%.1f%%), preventing discharge!", id(battery_soc).state);  
          } 
          u_new = 5.0f * roundf(u_new / 5.0f);
          u_new = clamp(u_new, -max_power_w, max_power_w);
          set_num(id(battery_power_target), u_new);
          ESP_LOGI("peak_shaver",
                   "Peak shaver: grid=%.0fW, target=%.0fW, err=%.0fW, home=%.0fW, batt_set = %.0fW",
                   grid, target, err, home, u_new);

